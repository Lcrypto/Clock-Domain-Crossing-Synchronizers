# Enable-based Data Bus Synchronizer 

## Introducation 
![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/692469f5-cf92-44e6-967a-0bd639765afa)

F0 represents a bank of flops which generates the bus that will cross the clock domain boundary. FE0 is another flop driven by the same clock – and it generates the enable signal – at the same time as the data is being generated by F0. This enable signal is synchronized through FE1 and FE2. Till the Enable signal does not reach the register bank F1 – the arrival of the data inputs on F1 does not matter. All clocks on F1 will be ignored – during this duration, due to lack of a valid enable. Hence, even if there is a setup/hold violation it does not matter.

By the time, enable passes through FE1 and FE2, it is expected that the data bus at the input of F1 register bank would have settled. At the next edge of clk2, the bank F1 will sample its data – which is all settled to its new value. So, F1 will sample the new value of the bus.

## Block Diagram
![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/b793b804-ef50-43c9-9389-71743ae7ac4d)

### Steps 
- One key idea in this design is that the synchronization event **(a pulse)** is converted into **a single toggle (either low to high, or high to low)** before being synchronized into the destination clock domain.
- Each toggle represents one event. **You need to be careful when resetting the synchronizer such that no unintended events are generated (i.e. if the source domain is reset on its own, and the toggle signal goes from high to low due to reset).**
- Source clock domain event to toggle generator
![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/a94dcb34-85c8-43d9-b1dc-31e1222e440f)

- The following circuit resides in the **source clock domai**n, and **converts an event** that needs to traverse the clock domain crossing (CDC) into a **toggle**, which cannot be missed due to sampling in the destination clock domain.
![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/fe5b5279-e797-4da5-943e-2961347eaea5)

- Destination clock domain toggle to enable pulse generator
![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/7d1edd2e-9be5-4c14-87ad-a09666ca7d71)

- Next, we need a circuit in the **destination clock domain** to **convert the toggle back into a pulse** to capture the multi-bit signal.
  ![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/51dd8a59-3fb9-4175-a2a9-61a197cc7fd4)


## Cost of Enable Synchronization
For using an enable synchronization based method, **an additional enable signal has to be generated**. This would mean **additional circuitry** for generating this enable signal. This in turn would mean **additional area and power**. Further, **similar costs also get added for synchronizing this additional enable signal**. However, this cost is more than offset, because individual bits of the bus are no longer required to be synchronized individually. 
So, we can save on one synchronizing flop per bit. And, since we are talking about vectored signals, so, there has to be multiple bits. That means, the savings are in terms of multiple flops. However, once the bussed signal is generated, it takes 3 triggering edges of the destination clock for the values to be sampled.

- On the first edge, the enable signal goes past FE1.
- On the second edge, the enable signal goes past FE2.
- And on the third edge, the bussed signal actually gets captured on the destination side register bank.

Contrast this with the double flop synchronizer, There, the data reaches the destination flop at the second triggering edge of the destination flop. So, Enable Synchronization scheme has an **additional latency**.
But, that’s the price that you have to pay – in order to **avoid the risk of capturing garbage data**.
